{"code":"import { DIRS, FOV, RNG, Path } from \"rot-js/lib/index\";\r\nimport { game, distance } from \"./Game\";\r\nvar Mob = /** @class */ (function () {\r\n    function Mob() {\r\n        this.sees = [];\r\n        this.path = [];\r\n        this.scent = [];\r\n        this.hate = 1;\r\n        game.mobs.push(this);\r\n    }\r\n    Mob.prototype.getSpeed = function () {\r\n        if (this == game.player) {\r\n            return 120 + this.hate;\r\n        }\r\n        return 100;\r\n    };\r\n    Mob.prototype.act = function () {\r\n        var _this = this;\r\n        if (this == game.player) {\r\n            game.engine.lock();\r\n            window.addEventListener(\"keydown\", this);\r\n        }\r\n        else {\r\n            if (this.path && this.path.length > 0) {\r\n                this.goTo(this.path.shift());\r\n            }\r\n            else {\r\n                this.path = [];\r\n                var goal = RNG.getItem(game.rooms).getCenter();\r\n                var pathfinder = new Path.AStar(goal[0], goal[1], function (x, y) { return game.at([x, y]).cost < 1000; }, { topology: 4 });\r\n                pathfinder.compute(this.at[0], this.at[1], function (x, y) {\r\n                    return _this.path.push([x, y]);\r\n                });\r\n                this.path.shift();\r\n            }\r\n        }\r\n    };\r\n    Mob.prototype.tile = function () {\r\n        return game.at(this.at);\r\n    };\r\n    Mob.prototype.goTo = function (newAt) {\r\n        var tile = this.tile();\r\n        var targetMob = game.at(newAt).mob;\r\n        if (targetMob) {\r\n            if (targetMob == game.player)\r\n                return;\r\n            if (this == game.player) {\r\n                targetMob.die();\r\n                this.hate = 0;\r\n            }\r\n            else {\r\n                if (RNG.getUniform() < 0.5)\r\n                    return;\r\n                else {\r\n                    targetMob.at = this.at.slice(0, 2);\r\n                    tile.mob = targetMob;\r\n                }\r\n            }\r\n        }\r\n        if (tile.mob == this)\r\n            tile.mob = null;\r\n        this.at = newAt.slice(0, 2);\r\n        this.tile().mob = this;\r\n        if (this != game.player) {\r\n            this.leaveScent();\r\n        }\r\n    };\r\n    Mob.prototype.die = function () {\r\n        var _this = this;\r\n        game.mobs = game.mobs.filter(function (m) { return m != _this; });\r\n        this.tile().mob = null;\r\n        game.engine._scheduler.remove(this);\r\n        var fov = new FOV.PreciseShadowcasting(function (x, y) { return game.safeAt([x, y]).cost < 1000; });\r\n        fov.compute(this.at[0], this.at[1], 3, function (x, y, r, vis) {\r\n            var tile = game.at([x, y]);\r\n            if (tile.symbol == \" \")\r\n                tile.symbol = \"*\";\r\n        });\r\n    };\r\n    Mob.prototype.leaveScent = function () {\r\n        var tile = game.at(this.at);\r\n        tile.mob = this;\r\n        if (tile.scent <= 0.01) {\r\n            this.scent.push(tile);\r\n        }\r\n        tile.scent = 1;\r\n    };\r\n    Mob.prototype.handleEvent = function (e) {\r\n        var _this = this;\r\n        var keyMap = {};\r\n        keyMap[38] = 0;\r\n        keyMap[33] = 1;\r\n        keyMap[39] = 2;\r\n        keyMap[34] = 3;\r\n        keyMap[40] = 4;\r\n        keyMap[35] = 5;\r\n        keyMap[37] = 6;\r\n        keyMap[36] = 7;\r\n        keyMap[12] = -1;\r\n        var code = e.keyCode;\r\n        if (!(code in keyMap)) {\r\n            return;\r\n        }\r\n        if (RNG.getUniform() < 0.3)\r\n            game.playerRaging = this.hate / 100 > RNG.getUniform();\r\n        if (game.playerRaging) {\r\n            var nearestD = 1000;\r\n            var nearestMob = null;\r\n            for (var _i = 0, _a = game.mobs; _i < _a.length; _i++) {\r\n                var m = _a[_i];\r\n                if (m == game.player)\r\n                    continue;\r\n                var d = distance(m.at, game.player.at);\r\n                if (d < nearestD) {\r\n                    nearestD = d;\r\n                    nearestMob = m;\r\n                }\r\n            }\r\n            if (nearestMob) {\r\n                var pathfinder = new Path.AStar(nearestMob.at[0], nearestMob.at[1], function (x, y) { return game.at([x, y]).cost < 1000; }, { topology: 4 });\r\n                this.path = [];\r\n                pathfinder.compute(this.at[0], this.at[1], function (x, y) {\r\n                    return _this.path.push([x, y]);\r\n                });\r\n                this.goTo(this.path[1]);\r\n            }\r\n        }\r\n        else {\r\n            var kmc = keyMap[code];\r\n            var diff = kmc == -1 ? [0, 0] : DIRS[8][kmc];\r\n            var newAt = [this.at[0] + diff[0], this.at[1] + diff[1]];\r\n            if (game.at(newAt).cost > 1000) {\r\n                return;\r\n            }\r\n            this.goTo(newAt);\r\n        }\r\n        this.lookAround();\r\n        window.removeEventListener(\"keydown\", this);\r\n        game.draw();\r\n        game.engine.unlock();\r\n    };\r\n    Mob.prototype.enrage = function (dHate) {\r\n        this.hate = Math.min(Math.max(0, this.hate + dHate), 100);\r\n    };\r\n    Mob.prototype.lookAround = function () {\r\n        var _this = this;\r\n        for (var _i = 0, _a = this.sees; _i < _a.length; _i++) {\r\n            var coord = _a[_i];\r\n            game.at(coord).visible = 0;\r\n        }\r\n        var seeThroughR = 4;\r\n        for (var x = -seeThroughR; x <= seeThroughR; x++)\r\n            for (var y = -seeThroughR; y <= seeThroughR; y++) {\r\n                var tile = game.safeAt([this.at[0] + x, this.at[1] + y]);\r\n                if (tile != game.emptyTile)\r\n                    tile.seen = 1;\r\n            }\r\n        var fov = new FOV.PreciseShadowcasting(function (x, y) { return game.safeAt([x, y]).cost < 1000; });\r\n        this.sees = [];\r\n        var dHate = game.playerRaging ? -0.3 : -0.15;\r\n        var seesFlower = false;\r\n        fov.compute(this.at[0], this.at[1], 20, function (x, y, r, vis) {\r\n            _this.sees.push([x, y]);\r\n            var tile = game.at([x, y]);\r\n            if (tile.symbol == \"âš˜\" && r <= 10)\r\n                seesFlower = true;\r\n            if (tile.mob && tile.mob != game.player) {\r\n                dHate += 15 / (r + 5);\r\n            }\r\n            tile.visible = (vis * (20 - r)) / 20;\r\n            tile.seen = 1;\r\n        });\r\n        if (this.tile().scent > 0.1) {\r\n            dHate += this.tile().scent * 2;\r\n        }\r\n        if (seesFlower) {\r\n            if (dHate > 0) {\r\n                dHate *= 2;\r\n            }\r\n            else {\r\n                dHate += -3;\r\n            }\r\n        }\r\n        this.enrage(dHate);\r\n    };\r\n    return Mob;\r\n}());\r\nexport default Mob;\r\n","references":["d:/1/monster-master/node_modules/rot-js/lib/index.d.ts","d:/1/monster-master/src/Game.ts","d:/1/monster-master/src/Game.ts"]}
